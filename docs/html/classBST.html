<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Advanced Programming Final Project: BST&lt; K, V, C &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Advanced Programming Final Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classBST-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BST&lt; K, V, C &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class implements a simple Binary Search Tree.  
 <a href="classBST.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="BST_8h_source.html">BST.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBST_1_1ConstIterator.html">ConstIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBST_1_1Iterator.html">Iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3cba9e816367006087a999b5e1027d72"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBST.html#a3cba9e816367006087a999b5e1027d72">BST</a> ()</td></tr>
<tr class="separator:a3cba9e816367006087a999b5e1027d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d30398500d92fe8a906c72677eaafb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBST.html#a77d30398500d92fe8a906c72677eaafb">~BST</a> ()</td></tr>
<tr class="separator:a77d30398500d92fe8a906c72677eaafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e6c0bc7ce4ad71686ae26ca3f71d77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBST.html">BST</a>&lt; K, V, C &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBST.html#a59e6c0bc7ce4ad71686ae26ca3f71d77">operator=</a> (const <a class="el" href="classBST.html">BST</a>&lt; K, V, C &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a59e6c0bc7ce4ad71686ae26ca3f71d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment.  <a href="#a59e6c0bc7ce4ad71686ae26ca3f71d77">More...</a><br /></td></tr>
<tr class="separator:a59e6c0bc7ce4ad71686ae26ca3f71d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447d9506675de51dbf56403fa2b910e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBST.html#a447d9506675de51dbf56403fa2b910e8">BST</a> (const <a class="el" href="classBST.html">BST</a>&lt; K, V, C &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a447d9506675de51dbf56403fa2b910e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy costructor.  <a href="#a447d9506675de51dbf56403fa2b910e8">More...</a><br /></td></tr>
<tr class="separator:a447d9506675de51dbf56403fa2b910e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af590b11504c8725c0c0b983ccda10517"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBST.html#af590b11504c8725c0c0b983ccda10517">BST</a> (<a class="el" href="classBST.html">BST</a>&lt; K, V, C &gt; &amp;&amp;rhs)</td></tr>
<tr class="memdesc:af590b11504c8725c0c0b983ccda10517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move costructor.  <a href="#af590b11504c8725c0c0b983ccda10517">More...</a><br /></td></tr>
<tr class="separator:af590b11504c8725c0c0b983ccda10517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487925834a1291eec64d6efac4fb9fab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBST.html">BST</a>&lt; K, V, C &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBST.html#a487925834a1291eec64d6efac4fb9fab">operator=</a> (const <a class="el" href="classBST.html">BST</a> &amp;&amp;rhs)</td></tr>
<tr class="memdesc:a487925834a1291eec64d6efac4fb9fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment.  <a href="#a487925834a1291eec64d6efac4fb9fab">More...</a><br /></td></tr>
<tr class="separator:a487925834a1291eec64d6efac4fb9fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d4d73ccb420ad1e0dbd36bc5252d74"><td class="memItemLeft" align="right" valign="top"><a id="a28d4d73ccb420ad1e0dbd36bc5252d74"></a>
<a class="el" href="classBST_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBST.html#a28d4d73ccb420ad1e0dbd36bc5252d74">begin</a> ()</td></tr>
<tr class="memdesc:a28d4d73ccb420ad1e0dbd36bc5252d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="classBST_1_1Iterator.html">Iterator</a> to the first in order node of the tree. <br /></td></tr>
<tr class="separator:a28d4d73ccb420ad1e0dbd36bc5252d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b050d8cffe441618e074e09139db869"><td class="memItemLeft" align="right" valign="top"><a id="a7b050d8cffe441618e074e09139db869"></a>
<a class="el" href="classBST_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBST.html#a7b050d8cffe441618e074e09139db869">end</a> ()</td></tr>
<tr class="memdesc:a7b050d8cffe441618e074e09139db869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the end of the tree, indicated by nullptr. <br /></td></tr>
<tr class="separator:a7b050d8cffe441618e074e09139db869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c1af62e5b5e0b119179f177633836e"><td class="memItemLeft" align="right" valign="top"><a id="ad8c1af62e5b5e0b119179f177633836e"></a>
<a class="el" href="classBST_1_1ConstIterator.html">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBST.html#ad8c1af62e5b5e0b119179f177633836e">begin</a> () const</td></tr>
<tr class="memdesc:ad8c1af62e5b5e0b119179f177633836e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the first node. <br /></td></tr>
<tr class="separator:ad8c1af62e5b5e0b119179f177633836e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1901ddfeb7c806d46ed363c115049363"><td class="memItemLeft" align="right" valign="top"><a id="a1901ddfeb7c806d46ed363c115049363"></a>
<a class="el" href="classBST_1_1ConstIterator.html">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBST.html#a1901ddfeb7c806d46ed363c115049363">end</a> () const</td></tr>
<tr class="memdesc:a1901ddfeb7c806d46ed363c115049363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the last node. <br /></td></tr>
<tr class="separator:a1901ddfeb7c806d46ed363c115049363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca4a971ca3c6239c78a167fff42afe5"><td class="memItemLeft" align="right" valign="top"><a id="a2ca4a971ca3c6239c78a167fff42afe5"></a>
<a class="el" href="classBST_1_1ConstIterator.html">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin</b> () const</td></tr>
<tr class="separator:a2ca4a971ca3c6239c78a167fff42afe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b8111ddbf10213f1cf97946cf8cccd"><td class="memItemLeft" align="right" valign="top"><a id="a44b8111ddbf10213f1cf97946cf8cccd"></a>
<a class="el" href="classBST_1_1ConstIterator.html">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cend</b> () const</td></tr>
<tr class="separator:a44b8111ddbf10213f1cf97946cf8cccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78994b2b2383be06e93f2f3882bbc7e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBST_1_1ConstIterator.html">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBST.html#a78994b2b2383be06e93f2f3882bbc7e6">find</a> (const K &amp;item) const</td></tr>
<tr class="memdesc:a78994b2b2383be06e93f2f3882bbc7e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Givena key value, it returns an <a class="el" href="classBST_1_1Iterator.html">Iterator</a> to a node in the tree.  <a href="#a78994b2b2383be06e93f2f3882bbc7e6">More...</a><br /></td></tr>
<tr class="separator:a78994b2b2383be06e93f2f3882bbc7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac149123e8192d8f8d29eee828c3ee74a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBST.html#ac149123e8192d8f8d29eee828c3ee74a">insert</a> (const std::pair&lt; K, V &gt; &amp;pair)</td></tr>
<tr class="memdesc:ac149123e8192d8f8d29eee828c3ee74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new node in the tree.  <a href="#ac149123e8192d8f8d29eee828c3ee74a">More...</a><br /></td></tr>
<tr class="separator:ac149123e8192d8f8d29eee828c3ee74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f96234b9a71bdb4c2edd88b0ef80743"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; K, V &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBST.html#a1f96234b9a71bdb4c2edd88b0ef80743">fromBSTtoVector</a> ()</td></tr>
<tr class="memdesc:a1f96234b9a71bdb4c2edd88b0ef80743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary function used in the balance function.  <a href="#a1f96234b9a71bdb4c2edd88b0ef80743">More...</a><br /></td></tr>
<tr class="separator:a1f96234b9a71bdb4c2edd88b0ef80743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb2fbf5e98852e77cf2d576d6944795"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBST.html#abdb2fbf5e98852e77cf2d576d6944795">fromVectortoBalance</a> (const std::vector&lt; std::pair&lt; K, V &gt;&gt; &amp;nodi, int primo, int ultimo)</td></tr>
<tr class="memdesc:abdb2fbf5e98852e77cf2d576d6944795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary function used in the balance routine.  <a href="#abdb2fbf5e98852e77cf2d576d6944795">More...</a><br /></td></tr>
<tr class="separator:abdb2fbf5e98852e77cf2d576d6944795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06274e4538ebbf7630058aa2da577ffe"><td class="memItemLeft" align="right" valign="top"><a id="a06274e4538ebbf7630058aa2da577ffe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBST.html#a06274e4538ebbf7630058aa2da577ffe">balance</a> ()</td></tr>
<tr class="memdesc:a06274e4538ebbf7630058aa2da577ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a balanced <a class="el" href="classBST.html" title="This class implements a simple Binary Search Tree. ">BST</a> starting from an unbalanced one. <br /></td></tr>
<tr class="separator:a06274e4538ebbf7630058aa2da577ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab126433ade0fa5711341d80cd6a498ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBST.html#ab126433ade0fa5711341d80cd6a498ff">clear</a> ()</td></tr>
<tr class="separator:ab126433ade0fa5711341d80cd6a498ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7caa3e87e5840631ecd016dcddca593"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBST.html#ae7caa3e87e5840631ecd016dcddca593">copy</a> (const std::unique_ptr&lt; Node &gt; &amp;curr_node)</td></tr>
<tr class="memdesc:ae7caa3e87e5840631ecd016dcddca593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supplementary function used to create a deep copy of a tree.  <a href="#ae7caa3e87e5840631ecd016dcddca593">More...</a><br /></td></tr>
<tr class="separator:ae7caa3e87e5840631ecd016dcddca593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4fdcab3a5e76bc3f1b75241caae4f99"><td class="memItemLeft" align="right" valign="top"><a id="af4fdcab3a5e76bc3f1b75241caae4f99"></a>
<a class="el" href="classBST_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBST.html#af4fdcab3a5e76bc3f1b75241caae4f99">find</a> (const K &amp;key)</td></tr>
<tr class="memdesc:af4fdcab3a5e76bc3f1b75241caae4f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">non const version of the find function <br /></td></tr>
<tr class="separator:af4fdcab3a5e76bc3f1b75241caae4f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:abf0033be2689fd4cfbeee149b114536b"><td class="memTemplParams" colspan="2">template&lt;class oK , class oV , class oC &gt; </td></tr>
<tr class="memitem:abf0033be2689fd4cfbeee149b114536b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBST.html#abf0033be2689fd4cfbeee149b114536b">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="classBST.html">BST</a>&lt; oK, oV, oC &gt; &amp;)</td></tr>
<tr class="memdesc:abf0033be2689fd4cfbeee149b114536b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the operator &lt;&lt;.  <a href="#abf0033be2689fd4cfbeee149b114536b">More...</a><br /></td></tr>
<tr class="separator:abf0033be2689fd4cfbeee149b114536b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class K, class V, class C = std::greater&lt;K&gt;&gt;<br />
class BST&lt; K, V, C &gt;</h3>

<p>This class implements a simple Binary Search Tree. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>is the typename of the key </td></tr>
    <tr><td class="paramname">V</td><td>is the typename of the value </td></tr>
    <tr><td class="paramname">C</td><td>is the typename of the operator used to compare different keys </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3cba9e816367006087a999b5e1027d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cba9e816367006087a999b5e1027d72">&#9670;&nbsp;</a></span>BST() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V, class C = std::greater&lt;K&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBST.html">BST</a>&lt; K, V, C &gt;::<a class="el" href="classBST.html">BST</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>constructor of a new <a class="el" href="classBST.html" title="This class implements a simple Binary Search Tree. ">BST</a> object </p>

</div>
</div>
<a id="a77d30398500d92fe8a906c72677eaafb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d30398500d92fe8a906c72677eaafb">&#9670;&nbsp;</a></span>~BST()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V, class C = std::greater&lt;K&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBST.html">BST</a>&lt; K, V, C &gt;::~<a class="el" href="classBST.html">BST</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>default destructor </p>

</div>
</div>
<a id="a447d9506675de51dbf56403fa2b910e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a447d9506675de51dbf56403fa2b910e8">&#9670;&nbsp;</a></span>BST() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V, class C = std::greater&lt;K&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBST.html">BST</a>&lt; K, V, C &gt;::<a class="el" href="classBST.html">BST</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBST.html">BST</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy costructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the tree that we want to use for initialization </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af590b11504c8725c0c0b983ccda10517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af590b11504c8725c0c0b983ccda10517">&#9670;&nbsp;</a></span>BST() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V, class C = std::greater&lt;K&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBST.html">BST</a>&lt; K, V, C &gt;::<a class="el" href="classBST.html">BST</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBST.html">BST</a>&lt; K, V, C &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move costructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the tree that we need to move </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab126433ade0fa5711341d80cd6a498ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab126433ade0fa5711341d80cd6a498ff">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V, class C = std::greater&lt;K&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBST.html">BST</a>&lt; K, V, C &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clears the current content of a given <a class="el" href="classBST.html" title="This class implements a simple Binary Search Tree. ">BST</a> object </p>

</div>
</div>
<a id="ae7caa3e87e5840631ecd016dcddca593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7caa3e87e5840631ecd016dcddca593">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBST.html">BST</a>&lt; K, V, C &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; Node &gt; &amp;&#160;</td>
          <td class="paramname"><em>curr_node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supplementary function used to create a deep copy of a tree. </p>
<p>This function is called by both the copy constructor and the copy assignemnt functions. To perform a deep copy we add a node with the same value as the one of the current node to a tree and then, if children are present, we call the the function on the children of the current node</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curr_node</td><td>a pointer to the current node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78994b2b2383be06e93f2f3882bbc7e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78994b2b2383be06e93f2f3882bbc7e6">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V, class C = std::greater&lt;K&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBST_1_1ConstIterator.html">ConstIterator</a> <a class="el" href="classBST.html">BST</a>&lt; K, V, C &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Givena key value, it returns an <a class="el" href="classBST_1_1Iterator.html">Iterator</a> to a node in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>the key value that we want to look up </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f96234b9a71bdb4c2edd88b0ef80743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f96234b9a71bdb4c2edd88b0ef80743">&#9670;&nbsp;</a></span>fromBSTtoVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; K, V &gt; &gt; <a class="el" href="classBST.html">BST</a>&lt; K, V, C &gt;::fromBSTtoVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary function used in the balance function. </p>
<p>Given a <a class="el" href="classBST.html" title="This class implements a simple Binary Search Tree. ">BST</a> object the function returns a vector of pairs key-value in order. </p>

</div>
</div>
<a id="abdb2fbf5e98852e77cf2d576d6944795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdb2fbf5e98852e77cf2d576d6944795">&#9670;&nbsp;</a></span>fromVectortoBalance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBST.html">BST</a>&lt; K, V, C &gt;::fromVectortoBalance </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; K, V &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>nodi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>primo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ultimo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary function used in the balance routine. </p>
<p>It creates a <a class="el" href="classBST.html" title="This class implements a simple Binary Search Tree. ">BST</a> starting from an ordered vector. It starts by setting the middle element of the vector as root and then calls the function recursevly on the left and right halves of the vector</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodi</td><td>is the ordered pairs vector </td></tr>
    <tr><td class="paramname">primo</td><td>the index of the first element </td></tr>
    <tr><td class="paramname">ultimo</td><td>the index of the last element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac149123e8192d8f8d29eee828c3ee74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac149123e8192d8f8d29eee828c3ee74a">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classBST.html">BST</a>&lt; K, V, C &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>pair</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new node in the tree. </p>
<p>If the node is the first one to be inserted it is set as the root of the tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pair</td><td>the key-value pair that we want to insert in our tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59e6c0bc7ce4ad71686ae26ca3f71d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e6c0bc7ce4ad71686ae26ca3f71d77">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V, class C = std::greater&lt;K&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBST.html">BST</a>&lt;K,V,C&gt;&amp; <a class="el" href="classBST.html">BST</a>&lt; K, V, C &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBST.html">BST</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the tree that we want to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a487925834a1291eec64d6efac4fb9fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487925834a1291eec64d6efac4fb9fab">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V, class C = std::greater&lt;K&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBST.html">BST</a>&lt;K,V,C&gt;&amp; <a class="el" href="classBST.html">BST</a>&lt; K, V, C &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBST.html">BST</a>&lt; K, V, C &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>tree that we want to move </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="abf0033be2689fd4cfbeee149b114536b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf0033be2689fd4cfbeee149b114536b">&#9670;&nbsp;</a></span>operator<<</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V, class C = std::greater&lt;K&gt;&gt; </div>
<div class="memtemplate">
template&lt;class oK , class oV , class oC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBST.html">BST</a>&lt; oK, oV, oC &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of the operator &lt;&lt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>the std::ostream where to print the result </td></tr>
    <tr><td class="paramname">bst</td><td>the <a class="el" href="classBST.html" title="This class implements a simple Binary Search Tree. ">BST</a> object we want to print </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="BST_8h_source.html">BST.h</a></li>
<li>BST.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
